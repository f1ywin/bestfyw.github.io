<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/bestfyw.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/bestfyw.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/bestfyw.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/bestfyw.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/bestfyw.github.io/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"f1ywin.github.io","root":"/bestfyw.github.io/","images":"/bestfyw.github.io/images","scheme":"Gemini","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/bestfyw.github.io/js/config.js"></script>

    <meta name="description" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://f1ywin.github.io/bestfyw.github.io/2023/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="冯耀文的博客">
<meta property="og:description" content="数据结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E7%A4%BA%E4%BE%8B.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E5%BD%A2%E5%BC%8F.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%98%E9%87%8F%E5%90%AB%E4%B9%89.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A0%91.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%90%E5%9B%BE.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%A0%E5%90%91%E5%9B%BE%E5%8F%8A%E5%85%B6%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/G1%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/G3%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84%E4%B8%80%E9%A2%97%E7%94%9F%E6%88%90%E6%A0%91.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E4%B8%AA%E6%9C%89%E5%90%91%E5%9B%BE%E5%8F%8A%E5%85%B6%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E5%8F%8A%E5%85%B6%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BD%91%E5%8F%8A%E5%85%B6%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%82%BB%E6%8E%A5%E8%A1%A8.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AOV-%E7%BD%91%E5%8F%8A%E5%85%B6%E6%8B%93%E6%89%91%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E4%BA%A7%E7%94%9F%E7%9A%84%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BD%91%E7%9A%84%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B1%82%E8%A7%A3.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LL.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LL%E7%A4%BA%E4%BE%8B.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RR.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RR%E7%A4%BA%E4%BE%8B.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LR.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LR%E7%A4%BA%E4%BE%8B.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RL.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RL%E7%A4%BA%E4%BE%8B.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B-%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4%E9%98%B6B-%E6%A0%91.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B-%E6%A0%91%E7%BB%93%E7%82%B9%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B-%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B+%E6%A0%91.png">
<meta property="og:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83.png">
<meta property="article:published_time" content="2023-06-25T02:16:55.000Z">
<meta property="article:modified_time" content="2025-01-17T06:55:29.248Z">
<meta property="article:author" content="fywfeng">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://f1ywin.github.io/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png">


<link rel="canonical" href="http://f1ywin.github.io/bestfyw.github.io/2023/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://f1ywin.github.io/bestfyw.github.io/2023/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","path":"2023/06/25/数据结构/","title":"数据结构"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构 | 冯耀文的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/bestfyw.github.io/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/bestfyw.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冯耀文的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/bestfyw.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/bestfyw.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/bestfyw.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/bestfyw.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%AA%E8%AE%BA"><span class="nav-text">绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%A0%94%E7%A9%B6%E5%86%85%E5%AE%B9"><span class="nav-text">1.数据结构的研究内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="nav-text">2.数据结构的相关概念和术语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">2.1数据逻辑结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">2.2数据存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-text">2.3数据的运算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%89%B9%E5%BE%81"><span class="nav-text">3.算法的概念与特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F%E6%8C%87%E6%A0%87"><span class="nav-text">4.算法效率的度量指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="nav-text">5.时间复杂度与空间复杂度的计算方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%A3%E6%AF%94%E8%BE%83"><span class="nav-text">6.常见时间复杂度类型与性能优劣比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">线性表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-text">栈和队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-text">串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-text">数组和广义表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">1.树的定义和基本术语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">1.1树的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">1.2树的基本术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">1.3树的性质</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">2.二叉树的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">3.二叉树的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">4.满二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.完全二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">6.二叉树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">6.1 顺序存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">6.2 链式存储结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">7.遍历二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">8.线索二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">9.树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">9.1双亲表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">9.1孩子表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">9.1孩子兄弟表示法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">10.树与二叉树的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">11.森林与二叉树的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">12.树和森林的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">12.1 树的遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">12.2 森林的遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-3-%E4%B8%8E%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">12.3 与遍历二叉树的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-text">13.最优二叉树(赫夫曼树)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-text">14.赫夫曼编码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="nav-text">1.定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">2.图的基本术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">3.图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">3.1邻接矩阵表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">3.2邻接表表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">3.3十字链表表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">3.4邻接多重表表示法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">4.最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95"><span class="nav-text">4.1普利姆算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95"><span class="nav-text">4.2克鲁斯卡尔算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">5.最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="nav-text">5.1迪杰斯特拉算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95"><span class="nav-text">5.2弗洛伊德算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">6.拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1AOV-%E7%BD%91"><span class="nav-text">6.1AOV-网</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-text">7.关键路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%80%BB%E7%BB%93"><span class="nav-text">8.总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-text">1.顺序查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-text">2.折半查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="nav-text">3.分块查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-text">4.树表的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="nav-text">4.1二叉排序树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-1%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">4.1.1二叉排序树的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-2%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-text">4.1.2二叉排序树的查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-3%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="nav-text">4.1.3二叉排序树的插入</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">4.2平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-1%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">4.2.1平衡二叉树的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-2%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B9%B3%E8%A1%A1%E8%B0%83%E6%95%B4"><span class="nav-text">4.2.2平衡二叉树的平衡调整</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3B-%E6%A0%91"><span class="nav-text">4.3B-树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-1B-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">4.3.1B-树的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-2B-%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-text">4.3.2B-树的查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-3B-%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="nav-text">4.3.3B-树的插入</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4B-%E6%A0%91"><span class="nav-text">4.4B+树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-text">5.散列表的查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">1.插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">1.1直接插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">1.2折半插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">1.3希尔排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-text">2.交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">2.1冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">2.2快速排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">3.选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">3.1简单选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2%E6%A0%91%E5%BD%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">3.2树形选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">3.3堆排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">4.归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">5.基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1%E5%A4%9A%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-text">5.1多关键字的排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2%E9%93%BE%E5%BC%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2链式基数排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="nav-text">6.外部排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E5%BD%92%E5%B9%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">6.1多路平衡归并的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">6.2置换-选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="nav-text">6.3最佳归并树</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fywfeng"
      src="/bestfyw.github.io/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">fywfeng</p>
  <div class="site-description" itemprop="description">终身学习，任务导向。持之以恒，严格自律。修身养性，正直谦卑。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/bestfyw.github.io/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/bestfyw.github.io/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/bestfyw.github.io/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/f1ywin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;f1ywin" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fyw1fyw@163.com" title="E-Mail → mailto:fyw1fyw@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://f1ywin.github.io/bestfyw.github.io/2023/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/bestfyw.github.io/images/avatar.jpg">
      <meta itemprop="name" content="fywfeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯耀文的博客">
      <meta itemprop="description" content="终身学习，任务导向。持之以恒，严格自律。修身养性，正直谦卑。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据结构 | 冯耀文的博客">
      <meta itemprop="description" content="数据结构">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-25 10:16:55" itemprop="dateCreated datePublished" datetime="2023-06-25T10:16:55+08:00">2023-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-17 14:55:29" itemprop="dateModified" datetime="2025-01-17T14:55:29+08:00">2025-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/bestfyw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

            <div class="post-description">数据结构</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="1-数据结构的研究内容"><a href="#1-数据结构的研究内容" class="headerlink" title="1.数据结构的研究内容"></a>1.数据结构的研究内容</h3><p>数据结构 (data structure)是带有结构特性的数据元素的集合，它研究的是 <strong>数据的逻辑结构和数据的物理结构以及它们之间的相互关系</strong> ，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。</p>
<h3 id="2-数据结构的相关概念和术语"><a href="#2-数据结构的相关概念和术语" class="headerlink" title="2.数据结构的相关概念和术语"></a>2.数据结构的相关概念和术语</h3><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容：<strong>逻辑结构、存储结构和数据的运算</strong>。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</p>
<h4 id="2-1数据逻辑结构"><a href="#2-1数据逻辑结构" class="headerlink" title="2.1数据逻辑结构"></a>2.1数据逻辑结构</h4><p>数据的逻辑结构是指<strong>数据元素之间的逻辑关系</strong>，即从逻辑关系上描述数据。它与数据的具体存储形式无关，是独立于计算机的。数据逻辑结构通常分为线性结构和非线性结构。典型的数据结构与其逻辑结构的对应关系如下：</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png" alt="数据结构-数据逻辑结构"></p>
<p>对于线性表、集合、树、图这四种典型的数据结构，他们分别有以下特点：\</p>
<p>集合结构：数据元素之间只存在 “同属于一个集合”的关系。<br>线性结构：数据元素之间只存在“一对一”的关系。<br>树形结构：数据元素之间存在“一对多”的关系。<br>图状结构或网状结构：数据元素之间存在“多对多”的关系。\</p>
<h4 id="2-2数据存储结构"><a href="#2-2数据存储结构" class="headerlink" title="2.2数据存储结构"></a>2.2数据存储结构</h4><p>数据的存储结构指的是<strong>数据结构在计算机中的表示</strong>，也称为物理结构，又称映像。它包括数据元素的表示和关系的表示。数据存储结构依赖于计算机语言，它是用计算机语言实现的逻辑结构。数据的线性存储结构主要有：顺序存储、链式存储、索引存储、散列存储。  </p>
<p>&emsp;1&gt; 顺序存储：把逻辑上相邻的数据元素存储在物理位置也相邻的存储单元里，元素之间的关系由存储单元之间的位置关系，即相邻关系来体现。如顺序表。<br>&emsp;优点：容易实现随机存取，每个元素占用最少的存储空间。<br>&emsp;缺点：只能使用相邻的一整块存储空间，容易产生较多的外部内存碎片。<br>&emsp;2&gt; 链式存储：使用表示元素存储地址的指针来表示元素之间的逻辑关系，此时不要求逻辑上相邻的数据元素在物理位置上也相邻。如单链表。<br>&emsp;优点：不会出现碎片内存，能充分利用存储单元。<br>&emsp;缺点：每个元素由于存储指针而占用额外的存储空间，且只能通过遍历实现顺序存取。<br>&emsp;3&gt; 索引存储：在存储数据元素的同时，建立一个附加的索引表。索引表中的每一项称为索引项项，其形式通常为(关键字，地址)。<br>&emsp;优点：检索速度快。<br>&emsp;缺点：附加的索引表会占用额外的存储空间。在添加或者删除数据元素时，需要同步修改索引表，因此会花费额外的时间。<br>&emsp;4&gt; 散列存储：根据元素的关键字以某种方式计算出该元素的存储地址，又称为 hash 存储。如哈希表。<br>&emsp;优点：检索、添加、删除的操作速度都很快。<br>&emsp;缺点：如果散列函数(或者 hash 函数)设计不好的话，可能会出现 hash 冲突，解决冲突又会增加时间和空间开销。<br>&emsp;而数据的非线性存储结构主要有：树形存储、图形存储。</p>
<h4 id="2-3数据的运算"><a href="#2-3数据的运算" class="headerlink" title="2.3数据的运算"></a>2.3数据的运算</h4><p>数据的运算主要体现为运算的定义，以及运算的实现。<br>运算的定义是针对数据逻辑结构的，它描述了运算所能实现的功能。<br>运算的实现是针对数据存储结构的，它描述了运算的具体操作过程。\</p>
<h3 id="3-算法的概念与特征"><a href="#3-算法的概念与特征" class="headerlink" title="3.算法的概念与特征"></a>3.算法的概念与特征</h3><p>算法的定义是：算法是解决特定问题的求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。<br>算法的特征包括：有穷性、确定性、输入、输出、可行性。<br>有穷性：一个算法必须总在执行的有穷步之后结束，每一步都可在有穷时间内完成，不会无限循环。<br>确定性：算法中每条指令必须有确定的含义。<br>输入：一个算法有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身给定了初始条件。<br>输出：一个算法有一个或多个输出。没有输出的算法毫无意义。<br>可行性：一个算法的任何计算步骤都是可以被分解为基本可执行的操作，每个操作都能够在有限时间内完成。\</p>
<h3 id="4-算法效率的度量指标"><a href="#4-算法效率的度量指标" class="headerlink" title="4.算法效率的度量指标"></a>4.算法效率的度量指标</h3><p>算法效率的度量指标用算法编制的程序在计算机上<strong>运行所消耗的时间</strong>和<strong>所额外开辟的内存空间</strong>来度量，分别称作算法的时间复杂度和算法的空间复杂度。二者通常用大O符号表示，通常称为大O表示法。表示的是，随着数据规模的增加运行时间的增长情况和额外开辟内存空间的增长情况。\</p>
<h3 id="5-时间复杂度与空间复杂度的计算方法"><a href="#5-时间复杂度与空间复杂度的计算方法" class="headerlink" title="5.时间复杂度与空间复杂度的计算方法"></a>5.时间复杂度与空间复杂度的计算方法</h3><p>算法在最好情况下的时间复杂度为<strong>最好时间复杂度</strong>，指的是算法计算量可能达到的最小值；称算法在最坏情况下的时间复杂度为<strong>最坏时间复杂度</strong>，指的是算法计算量可能达到的最大值；算法的<strong>平均时间复杂度</strong>是指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。\</p>
<h3 id="6-常见时间复杂度类型与性能优劣比较"><a href="#6-常见时间复杂度类型与性能优劣比较" class="headerlink" title="6.常见时间复杂度类型与性能优劣比较"></a>6.常见时间复杂度类型与性能优劣比较</h3><p>O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)\</p>
<p>其中，O(1)表示常数时间复杂度，O(log n)表示对数时间复杂度，O(n)表示线性时间复杂度，O(n log n)表示线性对数时间复杂度，O(n^2)表示平方时间复杂度，O(2^n)表示指数时间复杂度，O(n!)表示阶乘时间复杂度。\</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h2 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h2><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="1-树的定义和基本术语"><a href="#1-树的定义和基本术语" class="headerlink" title="1.树的定义和基本术语"></a>1.树的定义和基本术语</h3><p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E7%A4%BA%E4%BE%8B.png" alt="树的示例"></p>
<h4 id="1-1树的定义"><a href="#1-1树的定义" class="headerlink" title="1.1树的定义"></a>1.1树的定义</h4><p>树(Tree)是n(n≥0)个结点的有限集，它或为空树(n&#x3D;0)；或为非空树，对于非空树T：(1)有且仅有一个称之为根的结点；(2)除根结点以外的其余结点可分为m(m&gt;0)个互不相交的有限集T1, T2, …,$T_m$,其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。\</p>
<h4 id="1-2树的基本术语"><a href="#1-2树的基本术语" class="headerlink" title="1.2树的基本术语"></a>1.2树的基本术语</h4><p>(1)<strong>结点</strong>：树中的一个独立单元。包含一个数据元素及若干指向其子树的分支，如图中的A、B、C、D等。<br>(2)<strong>结点的度</strong>：结点拥有的子树个数称为结点的度。例如，A的度为3，C的度为1，F的度为0。<br>(3)<strong>树的度</strong>：树的度是树内各结点度的最大值。图所示的树的度为3。<br>(4)<strong>叶子</strong>：度为0的结点称为叶子或终端结点。结点K、L、F、G、M、I、J都是树的叶子。<br>(5)<strong>非终端结点</strong>：度不为0的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。<br>(6)<strong>双亲和孩子</strong>：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。例如，B的双亲为A，B的孩子有E和F。<br>(7)<strong>兄弟</strong>：同一个双亲的孩子之间互称兄弟。例如，H、I和J互为兄弟。<br>(8)<strong>祖先</strong>：从根到该结点所经分支上的所有结点。例如，M的祖先为A、D和H。<br>(9)<strong>子孙</strong>：以某结点为根的子树中的任一结点都称为该结点的子孙。如B的子孙为E、K、L和F。<br>(10)<strong>层次</strong>：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加1。<br>(11)<strong>堂兄弟</strong>：双亲在同一层的结点互为堂兄弟。例如，结点G与E、F、H、I、J互为堂兄弟。<br>(12)<strong>树的深度</strong>：树中结点的最大层次称为树的深度或高度。图所示的树的深度为4。<br>(13)<strong>有序树和无序树</strong>：如果将树中结点的各子树看成从左至右是有次序的(即不能互换)，则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。<br>(14)<strong>森林</strong>：是m(m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。\</p>
<h4 id="1-3树的性质"><a href="#1-3树的性质" class="headerlink" title="1.3树的性质"></a>1.3树的性质</h4><p>(1)树中的节点数等于所有结点的度数加1<br>(2)度为m的树中第i层上至多有$m^{i-1}$个节点<br>(3)高度为h的m叉树至多有$\frac{m^h-1}{m-1}$个结点<br>(4)具有n结点的m树的最小高度为$\vert \log_m^{n*(m-1)+1}\vert$<br>(5)具有n个结点的树的总边数为n-1条\</p>
<p><strong>常用的三个等式</strong>：</p>
<p>设总边数为L，总节点数为N，$n_i$表示度为i的结点的个数。<br>等式一：L &#x3D; N - 1<br>等式二：L &#x3D; $0<em>n_0+1</em>n_1+2<em>n_2+…+i</em>n_i$<br>等式三：N &#x3D; $n_0+n_1+n_2+…+n_i$\</p>
<h3 id="2-二叉树的定义"><a href="#2-二叉树的定义" class="headerlink" title="2.二叉树的定义"></a>2.二叉树的定义</h3><p>二叉树(Binary Tree)是n(n≥0)个结点所构成的集合，它或为空树(n&#x3D;0)；或为非空树，对于非空树T：<br>(1)有且仅有一个称之为根的结点；<br>(2)除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。<br>二叉树与树一样具有递归性质，二叉树与树的区别主要有以下两点：<br>(1)二叉树每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点)；<br>(2)二叉树的子树有左右之分，其次序不能任意颠倒。\</p>
<h3 id="3-二叉树的性质"><a href="#3-二叉树的性质" class="headerlink" title="3.二叉树的性质"></a>3.二叉树的性质</h3><p>二叉树具有下列重要特性：<br>性质1 在二叉树的第i层上至多有2i−1个结点(i≥1)。<br>性质2 深度为k的二叉树至多有2k−1个结点(k≥1)。<br>性质3 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0&#x3D;n2+1。<br>性质4 具有n个结点的完全二叉树的深度为$\lfloor\log_2^{n}\rfloor+1$。($\lfloor\rfloor$表示向下取整)<br>性质5 如果对一棵有n个结点的完全二叉树(其深度为$\lfloor\log_2^{n}\rfloor+1$)的结点按层序编号(从第1层到第$\log_2^{n}+1$层，每层从左到右)，则对任一结点i(1≤i≤n)，有:<br>&emsp;(1)如果i&#x3D;1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲PARENT(i)是结点i&#x2F;2。<br>&emsp;(2)如果2i&gt;n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子LCHILD(i)是结点2i。<br>&emsp;(3)如果2i+1&gt;n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i+1。\</p>
<p><strong>常用的三个等式</strong>：<br>设总边数为L，总节点数为N，$n_i$表示度为i的结点的个数。<br>等式一：L &#x3D; N - 1<br>等式二：L &#x3D; $0<em>n_0+1</em>n_1+2*n_2$<br>等式三：N &#x3D; $n_0+n_1+n_2$\</p>
<p><strong>具有N个节点的二叉树有$\frac{(2N)!}{(N+1)!N!}$种形态。</strong></p>
<h3 id="4-满二叉树"><a href="#4-满二叉树" class="headerlink" title="4.满二叉树"></a>4.满二叉树</h3><p>深度为k且含有2k−1个结点的二叉树，且每一层上的结点数都是最大结点数，即每一层i的结点数都具有最大值$2^{i−1}$。</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树"></p>
<h3 id="5-完全二叉树"><a href="#5-完全二叉树" class="headerlink" title="5.完全二叉树"></a>5.完全二叉树</h3><p>深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。<br>完全二叉树的特点是：<br>&emsp;(1)叶子结点只可能在层次最大的两层上出现；<br>&emsp;(2)对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完全二叉树"></p>
<h3 id="6-二叉树的存储结构"><a href="#6-二叉树的存储结构" class="headerlink" title="6.二叉树的存储结构"></a>6.二叉树的存储结构</h3><h4 id="6-1-顺序存储结构"><a href="#6-1-顺序存储结构" class="headerlink" title="6.1 顺序存储结构"></a>6.1 顺序存储结构</h4><p>顺序存储结构使用一组地址连续的存储单元来存储数据元素。利用二叉树的性质5来匹配位置索引和值。例如，1号索引为根节点，则其左孩子节点索引为2，右孩子节点索引为3，以此类推。<br>顺序存储结构适合存储完全二叉树，因为每一个空间元素都被利用起来了。\</p>
<h4 id="6-2-链式存储结构"><a href="#6-2-链式存储结构" class="headerlink" title="6.2 链式存储结构"></a>6.2 链式存储结构</h4><p>如图所示：<br><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt="二叉树的链式存储"></p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="二叉树的链式存储示意图"></p>
<h3 id="7-遍历二叉树"><a href="#7-遍历二叉树" class="headerlink" title="7.遍历二叉树"></a>7.遍历二叉树</h3><p>三种遍历方式，根左右，左根右，左右根。</p>
<h3 id="8-线索二叉树"><a href="#8-线索二叉树" class="headerlink" title="8.线索二叉树"></a>8.线索二叉树</h3><p>如图所示：</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E5%BD%A2%E5%BC%8F.png" alt="线索二叉树的结点形式"></p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%98%E9%87%8F%E5%90%AB%E4%B9%89.png" alt="线索二叉树变量含义"></p>
<p>二叉树的线索化，分为三类，先序线索二叉树，中序线索二叉树，后续线索二叉树。即为分别按照相应的遍历方式得到的线索二叉树。</p>
<h3 id="9-树的存储结构"><a href="#9-树的存储结构" class="headerlink" title="9.树的存储结构"></a>9.树的存储结构</h3><h4 id="9-1双亲表示法"><a href="#9-1双亲表示法" class="headerlink" title="9.1双亲表示法"></a>9.1双亲表示法</h4><p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="树的双亲表示法"></p>
<h4 id="9-1孩子表示法"><a href="#9-1孩子表示法" class="headerlink" title="9.1孩子表示法"></a>9.1孩子表示法</h4><p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="树的孩子表示法"></p>
<h4 id="9-1孩子兄弟表示法"><a href="#9-1孩子兄弟表示法" class="headerlink" title="9.1孩子兄弟表示法"></a>9.1孩子兄弟表示法</h4><p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="树的孩子兄弟表示法"></p>
<h3 id="10-树与二叉树的转换"><a href="#10-树与二叉树的转换" class="headerlink" title="10.树与二叉树的转换"></a>10.树与二叉树的转换</h3><p>树转二叉树：将兄弟结点相连，保留最左侧第一个子节点与根节点相连，其他子节点与根节点断开。重复每一个子树以上行为。最后变形即可。</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="树转二叉树"></p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A0%91.png" alt="二叉树转树"></p>
<h3 id="11-森林与二叉树的转换"><a href="#11-森林与二叉树的转换" class="headerlink" title="11.森林与二叉树的转换"></a>11.森林与二叉树的转换</h3><p>森林转二叉树：将森林中的每个树转化为二叉树，再将转化的二叉树以此放在二叉树的右子树上。<br>二叉树转森林：过程与森林转二叉树相反。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="森林转二叉树"></p>
<h3 id="12-树和森林的遍历"><a href="#12-树和森林的遍历" class="headerlink" title="12.树和森林的遍历"></a>12.树和森林的遍历</h3><h4 id="12-1-树的遍历"><a href="#12-1-树的遍历" class="headerlink" title="12.1 树的遍历"></a>12.1 树的遍历</h4><p>由树结构的定义可引出两种次序遍历树的方法：一种是先根(次序)遍历树，即：先访问树的根结点，然后依次先根遍历根的每棵子树；<br>另一种是后根(次序)遍历，即先依次后根遍历每棵子树，然后访问根结点。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="树的遍历"></p>
<h4 id="12-2-森林的遍历"><a href="#12-2-森林的遍历" class="headerlink" title="12.2 森林的遍历"></a>12.2 森林的遍历</h4><p>按照森林和树相互递归的定义，可以推出森林的两种遍历方法：先序遍历和中序遍历。\</p>
<p>(1)先序遍历森林若森林非空，则可按下述规则遍历：① 访问森林中第一棵树的根结点；② 先序遍历第一棵树的根结点的子树森林；③ 先序遍历除去第一棵树之后剩余的树构成的森林。<br>(2)中序遍历森林若森林非空，则可按下述规则遍历：① 中序遍历森林中第一棵树的根结点的子树森林；② 访问第一棵树的根结点；③ 中序遍历除去第一棵树之后剩余的树构成的森林。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="森林的遍历"></p>
<h4 id="12-3-与遍历二叉树的关系"><a href="#12-3-与遍历二叉树的关系" class="headerlink" title="12.3 与遍历二叉树的关系"></a>12.3 与遍历二叉树的关系</h4><p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="树与森林与二叉树遍历的对应关系"></p>
<h3 id="13-最优二叉树-赫夫曼树"><a href="#13-最优二叉树-赫夫曼树" class="headerlink" title="13.最优二叉树(赫夫曼树)"></a>13.最优二叉树(赫夫曼树)</h3><p>哈夫曼(Huffman)树又称最优树，是一类带权路径长度最短的树。<br><strong>定义</strong>：假设有m个权值{w1, w2,…, wm}，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为wi，则其中带权路径长度WPL最小的二叉树称做最优二叉树或哈夫曼树。<br><strong>路径</strong>：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。<br><strong>路径长度</strong>：路径上的分支数目称作路径长度。<br><strong>树的路径长度</strong>：从树根到每一结点的路径长度之和。<br><strong>权</strong>：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。在数据结构中，实体有结点(元素)和边(关系)两大类，所以对应有结点权和边权。结点权或边权具体代表什么意义，由具体情况决定。如果在一棵树中的结点上带有权值，则对应的就有带权树等概念。<br><strong>结点的带权路径长度</strong>：从该结点到树根之间的路径长度与结点上权的乘积。<br><strong>树的带权路径长度</strong>：树中所有叶子结点的带权路径长度之和。\</p>
<p><strong>性质</strong>：</p>
<p>(1)一棵有n个叶子结点的哈夫曼树共有2n-1个结点。</p>
<h3 id="14-赫夫曼编码"><a href="#14-赫夫曼编码" class="headerlink" title="14.赫夫曼编码"></a>14.赫夫曼编码</h3><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p><strong>图(Graph)<strong>G由两个集合V和E组成，记为G&#x3D;(V, E)，其中V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。<br>对于图G，若边集E(G)为有向边的集合，则称该图为</strong>有向图</strong>；若边集E(G)为无向边的集合，则称该图为<strong>无向图</strong>。<br>在有向图中，顶点对&lt;x，y&gt;是有序的，它称为从顶点x到顶点y的一条有向边。因此，&lt;x，y&gt;与&lt;y，x&gt;是不同的两条边。顶点对用一对尖括号括起来，x是有向边的始点，y是有向边的终点。&lt;x，y&gt;也称作一条弧，则x为弧尾，y为弧头。<br>在无向图中，顶点对(x, y)是无序的，它称为与顶点x和顶点y相关联的一条边。这条边没有特定的方向，(x, y)与(y, x)是同一条边。为了有别于有向图，无向图的顶点对用一对圆括号括起来。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE.png" alt="图"><br> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>图1 图的示例</strong></p>
<h3 id="2-图的基本术语"><a href="#2-图的基本术语" class="headerlink" title="2.图的基本术语"></a>2.图的基本术语</h3><p>(1)<strong>子图</strong>：假设有两个图G&#x3D;(V, E)和G′&#x3D;(V′, E′)，如果V′′V且E′′ E，则称G′为G的子图。<br><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%90%E5%9B%BE.png" alt="子图"><br>                &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>图2 子图的示例</strong></p>
<p>(2)<strong>无向完全图和有向完全图</strong>：对于无向图，若具有<strong>n(n−1)&#x2F;2</strong>条边，则称为<strong>无向完全图</strong>。对于有向图，若具有n(n−1)条弧，则称为<strong>有向完全图</strong>。<br>简单理解为：每一个点都有边与其他的点相连。</p>
<p>(3)<strong>稀疏图和稠密图</strong>：有很少条边或弧(如e&lt;$n{log_2^{n}}$)的图称为稀疏图，反之称为稠密图。</p>
<p>(4)<strong>权和网</strong>：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的<strong>权</strong>。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为<strong>网</strong>。</p>
<p>(5)<strong>邻接点</strong>：对于无向图G，如果图的边(v, v′)∈E，则称顶点v和v′互为邻接点，即v和v′相邻接。边(v, v′)依附于顶点v和v′，或者说边(v, v′)与顶点v和v′相关联。</p>
<p>(6)<strong>度、入度和出度</strong>：顶点v的度是指和v相关联的边的数目，记为TD(v)。例如，图1中G2的顶点v3的度是3。对于有向图，顶点v的度分为入度和出度。<br><strong>入度</strong>是以顶点v为头的弧的数目，记为ID(v)；<br><strong>出度</strong>是以顶点v为尾的弧的数目，记为OD(v)。顶点v的度为TD(v)&#x3D;ID(v)+OD(v)。<br>例如，图1中G1的顶点v1的入度ID(v1)&#x3D;1，出度OD(v1)&#x3D;2，度TD(v1)&#x3D;ID(v1)+OD(v1)&#x3D;3。<br>一般地，如果顶点vi的度记为TD(vi)，那么一个有n个顶点，e条边的图，满足如下关系：$\frac{1}{2}\sum_{i&#x3D;1}^{n}{TD(v_i)}$\</p>
<p>(7)<strong>路径和路径长度</strong>：在无向图G中，从顶点v到顶点v′的路径是一个顶点序列(v&#x3D;vi,0, vi,1,…, vi,m&#x3D;v′)，其中(vi,j−1, vi,j)∈E，1≤j≤m。如果G是有向图，则路径也是有向的，顶点序列应满足&lt;vi,j−1,vi,j&gt;∈E, 1≤j≤m。<strong>路径长度</strong>是一条路径上经过的边或弧的数目。</p>
<p>(8)<strong>回路或环</strong>：第一个顶点和最后一个顶点相同的路径称为<strong>回路或环</strong>。</p>
<p>(9)<strong>简单路径、简单回路或简单环</strong>：序列中顶点不重复出现的路径称为<strong>简单路径</strong>。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为<strong>简单回路或简单环</strong>。</p>
<p>(10)<strong>连通、连通图和连通分量</strong>：在无向图G中，如果从顶点v到顶点v′有路径，则称v和v′是连通的。如果对于图中任意两个顶点$v_i$、$v_j$∈V，$v_i$和$v_j$都是连通的，则称G是<strong>连通图</strong>。图1中的G2就是一个连通图，而图3(a)中的G3则是非连通图，但G3有3个连通分量，如图3(b)所示。所谓<strong>连通分量</strong>，指的是无向图中的极大连通子图。</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%A0%E5%90%91%E5%9B%BE%E5%8F%8A%E5%85%B6%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt="无向图及其连通分量"><br> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>图3 无向图及其连通分量</strong></p>
<p>(11)<strong>强连通图和强连通分量</strong>：在有向图G中，如果对于每一对$v_i$,$v_j$∈V, $v_i$≠$v_j$，从$v_i$到$v_j$和从$v_j$到$v_i$都存在路径，则称G是<strong>强连通图</strong>。有向图中的极大强连通子图称作有向图的强连通分量。例如图1(a)中的G1不是强连通图，但它有两个强连通分量，如图4所示。</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/G1%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt="G1的两个强连通分量"><br>&emsp;&emsp;&emsp;<strong>图4 G1的两个强连通分量</strong></p>
<p>(12)<strong>连通图的生成树</strong>：一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n−1条边，这样的连通子图称为<strong>连通图的生成树</strong>。图5所示为G3中最大连通分量的一棵生成树。如果在一棵生成树上添加一条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/G3%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84%E4%B8%80%E9%A2%97%E7%94%9F%E6%88%90%E6%A0%91.png" alt="G3的最大连通分量的一颗生成树"><br>&emsp;&emsp;&emsp;<strong>图5 G3的最大连通分量的一颗生成树</strong></p>
<p>(13)有向树和生成森林：有一个顶点的入度为0，其余顶点的入度均为1的有向图称为有向树。一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。图6.6所示为其一例。</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E4%B8%AA%E6%9C%89%E5%90%91%E5%9B%BE%E5%8F%8A%E5%85%B6%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97.png" alt="一个有向图及其生成森林"><br>                &emsp;&emsp;<strong>图6 一个有向图及其生成森林</strong></p>
<h3 id="3-图的存储结构"><a href="#3-图的存储结构" class="headerlink" title="3.图的存储结构"></a>3.图的存储结构</h3><h4 id="3-1邻接矩阵表示法"><a href="#3-1邻接矩阵表示法" class="headerlink" title="3.1邻接矩阵表示法"></a>3.1邻接矩阵表示法</h4><p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E5%8F%8A%E5%85%B6%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="图及其邻接矩阵"></p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BD%91%E5%8F%8A%E5%85%B6%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="网及其邻接矩阵"></p>
<p>(1)优点<br>① 便于判断两个顶点之间是否有边，即根据A[i][j]&#x3D;0或1来判断。<br>② 便于计算各个顶点的度。对于无向图，邻接矩阵第i行元素之和就是顶点i的度；对于有向图，第i行元素之和就是顶点i的出度，第i列元素之和就是顶点i的入度。<br>(2)缺点<br>① 不便于增加和删除顶点。<br>② 不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为O(n2)。<br>③ 空间复杂度高。如果是有向图，n个顶点需要n2个单元存储边。如果是无向图，因其邻接矩阵是对称的，所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角(或上三角)的元素，这样需要n(n−1)&#x2F;2个单元即可。但无论以何种方式存储，邻接矩阵表示法的空间复杂度均为O(n2)，这对于稀疏图而言尤其浪费空间。\</p>
<h4 id="3-2邻接表表示法"><a href="#3-2邻接表表示法" class="headerlink" title="3.2邻接表表示法"></a>3.2邻接表表示法</h4><p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt="邻接表"></p>
<p>(1)优点<br>① 便于增加和删除顶点。<br>② 便于统计边的数目，按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为O(n+e)。<br>③ 空间效率高。对于一个具有n个顶点e条边的图G，若G是无向图，则在其邻接表表示中有n个顶点表结点和2e个边表结点；若G是有向图，则在它的邻接表表示或逆邻接表表示中均有n个顶点表结点和e个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为O(n+e)，适合表示稀疏图。对于稠密图，考虑到邻接表中要附加链域，因此常采取邻接矩阵表示法。<br>(2)缺点<br>① 不便于判断顶点之间是否有边，要判定vi和vj之间是否有边，就需扫描第i个边表，最坏情况下要耗费O(n)时间。<br>② 不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点vi的度是第i个边表中的结点个数。在有向图的邻接表中，第i个边表上的结点个数是顶点vi的出度，但求vi的入度较困难，需遍历各顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的入度容易，而求顶点的出度较难。\</p>
<h4 id="3-3十字链表表示法"><a href="#3-3十字链表表示法" class="headerlink" title="3.3十字链表表示法"></a>3.3十字链表表示法</h4><p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8.png" alt="十字链表"></p>
<h4 id="3-4邻接多重表表示法"><a href="#3-4邻接多重表表示法" class="headerlink" title="3.4邻接多重表表示法"></a>3.4邻接多重表表示法</h4><p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8.png" alt="邻接多重表"></p>
<h3 id="4-最小生成树"><a href="#4-最小生成树" class="headerlink" title="4.最小生成树"></a>4.最小生成树</h3><h4 id="4-1普利姆算法"><a href="#4-1普利姆算法" class="headerlink" title="4.1普利姆算法"></a>4.1普利姆算法</h4><p>假设N&#x3D;(V, E)是连通网，TE是N上最小生成树中边的集合。<br>① U&#x3D;{u0}(u0∈V)，TE&#x3D;{}。<br>② 在所有u∈U，v∈V−U的边(u, v)∈E中找一条权值最小的边(u0, v0)并入集合TE，同时v0并入U。<br>③ 重复②，直至U&#x3D;V为止。此时TE中必有n−1条边，则T&#x3D;(V, TE)为N的最小生成树。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95.png" alt="普利姆算法"></p>
<h4 id="4-2克鲁斯卡尔算法"><a href="#4-2克鲁斯卡尔算法" class="headerlink" title="4.2克鲁斯卡尔算法"></a>4.2克鲁斯卡尔算法</h4><p>假设连通网N&#x3D;(V, E)，将N中的边按权值从小到大的顺序排列。<br>① 初始状态为只有n个顶点而无边的非连通图T&#x3D;(V, {})，图中每个顶点自成一个连通分量。<br>② 在E中选择权值最小的边，若该边依附的顶点落在T中不同的连通分量上(即不形成回路)，则将此边加入到T中，否则舍去此边而选择下一条权值最小的边。<br>③ 重复②，直至T中所有顶点都在同一连通分量上为止。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95.png" alt="克鲁斯卡尔算法"></p>
<h3 id="5-最短路径"><a href="#5-最短路径" class="headerlink" title="5.最短路径"></a>5.最短路径</h3><h4 id="5-1迪杰斯特拉算法"><a href="#5-1迪杰斯特拉算法" class="headerlink" title="5.1迪杰斯特拉算法"></a>5.1迪杰斯特拉算法</h4><p>对于网N&#x3D;(V, E)，将N中的顶点分成两组：<br>第一组S：已求出的最短路径的终点集合(初始时只包含源点v0)。<br>第二组V−S：尚未求出的最短路径的顶点集合(初始时为V−{v0})。算法将按各顶点与v0间最短路径长度递增的次序，逐个将集合V−S中的顶点加入到集合S中去。在这个过程中，总保持从v0到集合S中各顶点的路径长度始终不大于到集合V−S中各顶点的路径长度。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95.png" alt="克鲁斯卡尔算法"></p>
<h4 id="5-2弗洛伊德算法"><a href="#5-2弗洛伊德算法" class="headerlink" title="5.2弗洛伊德算法"></a>5.2弗洛伊德算法</h4><p>将vi到vj的最短路径长度初始化，即D[i][j]&#x3D;G.arcs[i][j]，然后进行n次比较和更新。<br>① 在vi和vj间加入顶点v0，比较(vi, vj)和(vi, v0, vj)的路径长度，取其中较短者作为vi到vj的中间顶点序号不大于0的最短路径。<br>② 在vi和vj间加入顶点v1，得到(vi,…, v1)和(v1,…, vj)，其中(vi,…, v1)是vi到v1的且中间顶点的序号不大于0的最短路径，(v1,…, vj)是v1到vj的且中间顶点的序号不大于0的最短路径，这两条路径已在上一步中求出。比较(vi,…, v1,…,vj)与上一步求出的vi到vj的中间顶点序号不大于0的最短路径，取其中较短者作为vi到vj的中间顶点序号不大于1的最短路径。<br>③ 依次类推，在vi和vj间加入顶点vk，若(vi,…, vk)和(vk,…, vj)分别是从vi到vk和从vk到vj的中间顶点的序号不大于k−1的最短路径，则将(vi,…, vk,…, vj)和已经得到的从vi到vj且中间顶点序号不大于k−1的最短路径相比较，其长度较短者便是从vi到vj的中间顶点的序号不大于k的最短路径。这样，经过n次比较后，最后求得的必是从vi到vj的最短路径。按此方法，可以同时求得各对顶点间的最短路径。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95.png" alt="弗洛伊德算法"></p>
<h3 id="6-拓扑排序"><a href="#6-拓扑排序" class="headerlink" title="6.拓扑排序"></a>6.拓扑排序</h3><h4 id="6-1AOV-网"><a href="#6-1AOV-网" class="headerlink" title="6.1AOV-网"></a>6.1AOV-网</h4><p>一个无环的有向图称作有向无环图(Directed Acycline Graph)，简称DAG图。</p>
<p>用顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网(Activity On Vertex Network)，简称AOV-网。</p>
<p><strong>拓扑排序</strong>就是将AOV-网中所有顶点排成一个线性序列，该序列满足：若在AOV-网中由顶点vi到顶点vj有一条路径，则在该线性序列中的顶点vi必定在顶点vj之前。</p>
<p>拓扑排序过程：</p>
<p>(1)在有向图中选一个无前驱的顶点且输出它。<br>(2)从图中删除该顶点和所有以它为尾的弧。<br>(3)重复(1)和(2)，直至不存在无前驱的顶点。<br>(4)若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环，否则输出的顶点序列即为一个拓扑序列。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AOV-%E7%BD%91%E5%8F%8A%E5%85%B6%E6%8B%93%E6%89%91%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E4%BA%A7%E7%94%9F%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="AOV-网及其拓扑有序序列产生的过程"></p>
<h3 id="7-关键路径"><a href="#7-关键路径" class="headerlink" title="7.关键路径"></a>7.关键路径</h3><p>与AOV-网相对应的是AOE-网(Activity On Edge)，即以边表示活动的网。AOE-网是一个带权的有向无环图，其中，顶点表示事件，弧表示活动，权表示活动持续的时间。通常，AOE-网可用来估算工程的完成时间。</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BD%91%E7%9A%84%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B1%82%E8%A7%A3.png" alt="网的关键路径求解"></p>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h3><p>(1)根据不同的分类规则，图分为多种类型：无向图、有向图、完全图、连通图、强连通图、带权图(网)、稀疏图和稠密图等。邻接点、路径、回路、度、连通分量、生成树等是在图的算法设计中常用到的重要术语。</p>
<p>(2)图的存储方式有两大类：以边集合方式的表示法和以链接方式的表示法。其中，以边集合方式表示的为邻接矩阵，以链接方式表示的包括邻接表、十字链表和邻接多重表。邻接矩阵表示法借助二维数组来表示元素之间的关系，实现起来较为简单；邻接表、十字链表和邻接多重表都属于链式存储结构，实现起来较为复杂。在实际应用中具体采取哪种存储表示，可以根据图的类型和实际算法的基本思想进行选择。其中，邻接矩阵和邻接表是两种常用的存储结构，二者之间的比较如表</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="邻接矩阵和邻接表的比较"></p>
<p>(3)图的遍历算法是实现图的其他运算的基础，图的遍历方法有两种：深度优先搜索遍历和广度优先搜索遍历。深度优先搜索遍历类似于树的先序遍历，借助于栈结构来实现(递归)；广度优先搜索遍历类似于树的层次遍历，借助于队列结构来实现。两种遍历方法的不同之处仅仅在于对顶点访问的顺序不同，所以时间复杂度相同。当用邻接矩阵存储时，时间复杂度为均O(n2)，用邻接表存储时，时间复杂度均为O(n+e)。</p>
<p>(4)图的很多算法与实际应用密切相关，比较常用的算法包括构造最小生成树算法、求解最短路径算法、拓扑排序和求解关键路径算法。</p>
<p>① 构造最小生成树有普里姆算法和克鲁斯卡尔算法，两者都能达到同一目的。但前者算法思想的核心是归并点，时间复杂度是O(n2)，适用于稠密网；后者是归并边，时间复杂度是O(elog2e)，适用于稀疏网。<br>② 最短路径算法：一种是迪杰斯特拉算法，求从某个源点到其余各顶点的最短路径，求解过程是按路径长度递增的次序产生最短路径，时间复杂度是O(n2)；另一种是弗洛伊德算法，求每一对顶点之间的最短路径，时间复杂度是O(n3)，从实现形式上来说，这种算法比以图中的每个顶点为源点n次调用迪杰斯特拉算法更为简洁。<br>③ 拓扑排序和关键路径都是有向无环图的应用。拓扑排序是基于用顶点表示活动的有向图，即AOV-网。对于不存在环的有向图，图中所有顶点一定能够排成一个线性序列，即拓扑序列，拓扑序列是不唯一的。用邻接表表示图，拓扑排序的时间复杂度为O(n+e)。<br>④ 关键路径算法是基于用弧表示活动的有向图，即AOE-网。关键路径上的活动叫做关键活动，这些活动是影响工程进度的关键，它们的提前或拖延将使整个工程提前或拖延。关键路径是不唯一的。关键路径算法的实现是在拓扑排序的基础上，用邻接表表示图，关键路径算法的时间复杂度为O(n+e)。\</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1.顺序查找"></a>1.顺序查找</h3><p>顺序查找(Sequential Search)的查找过程为：从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。</p>
<p>顺序查找方法既适用于线性表的顺序存储结构，又适用于线性表的链式存储结构。</p>
<h3 id="2-折半查找"><a href="#2-折半查找" class="headerlink" title="2.折半查找"></a>2.折半查找</h3><p>折半查找(Binary Search)也称二分查找，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p>
<p>折半查找的查找过程为：从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功；如果给定值大于或者小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。</p>
<h3 id="3-分块查找"><a href="#3-分块查找" class="headerlink" title="3.分块查找"></a>3.分块查找</h3><p>分块查找(Blocking Search)又称索引顺序查找，这是一种性能介于顺序查找和折半查找之间的一种查找方法。</p>
<h3 id="4-树表的查找"><a href="#4-树表的查找" class="headerlink" title="4.树表的查找"></a>4.树表的查找</h3><h4 id="4-1二叉排序树"><a href="#4-1二叉排序树" class="headerlink" title="4.1二叉排序树"></a>4.1二叉排序树</h4><h5 id="4-1-1二叉排序树的定义"><a href="#4-1-1二叉排序树的定义" class="headerlink" title="4.1.1二叉排序树的定义"></a>4.1.1二叉排序树的定义</h5><p>二叉排序树(Binary Sort Tree)又称二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。<br>二叉排序树的定义二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>(1)若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>(2)若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>(3)它的左、右子树也分别为二叉排序树。二叉排序树是递归定义的。由定义可以得出二叉排序树的一个重要性质：中序遍历一棵二叉树时可以得到一个结点值递增的有序序列。\</p>
<h5 id="4-1-2二叉排序树的查找"><a href="#4-1-2二叉排序树的查找" class="headerlink" title="4.1.2二叉排序树的查找"></a>4.1.2二叉排序树的查找</h5><p>因为二叉排序树可以看成是一个有序表，所以在二叉排序树上进行查找和折半查找类似，也是一个逐步缩小查找范围的过程。</p>
<p>二叉排序树的递归查找：<br>① 若二叉排序树为空，则查找失败，返回空指针。<br>② 若二叉排序树非空，将给定值key与根结点的关键字T-&gt;data.key进行比较：<br>&emsp;若key等于T-&gt;data.key，则查找成功，返回根结点地址；<br>&emsp;若key小于T-&gt;data.key，则递归查找左子树；<br>&emsp;若key大于T-&gt;data.key，则递归查找右子树。\</p>
<h5 id="4-1-3二叉排序树的插入"><a href="#4-1-3二叉排序树的插入" class="headerlink" title="4.1.3二叉排序树的插入"></a>4.1.3二叉排序树的插入</h5><p>二叉排序树的插入操作是以查找为基础的。要将一个关键字值为key的结点S插入到二叉排序树中，则需要从根结点向下查找，当树中不存在关键字等于key的结点时才进行插入。新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。</p>
<p>二叉排序树的插入：<br>① 若二叉排序树为空，则待插入结点S作为根结点插入到空树中。<br>② 若二叉排序树非空，则将key与根结点的关键字T-&gt;data.key进行比较：<br>&emsp;若key小于T-&gt;data.key，则将S插入左子树；<br>&emsp;若key大于T-&gt;data.key，则将*S插入右子树。\</p>
<h4 id="4-2平衡二叉树"><a href="#4-2平衡二叉树" class="headerlink" title="4.2平衡二叉树"></a>4.2平衡二叉树</h4><h5 id="4-2-1平衡二叉树的定义"><a href="#4-2-1平衡二叉树的定义" class="headerlink" title="4.2.1平衡二叉树的定义"></a>4.2.1平衡二叉树的定义</h5><p>平衡二叉树或者是空树，或者是具有如下特征的二叉排序树：<br>(1)左子树和右子树的深度之差的绝对值不超过1；<br>(2)左子树和右子树也是平衡二叉树。<br>若将二叉树上结点的平衡因子(Balance Factor，BF)定义为该结点左子树和右子树的深度之差，则平衡二叉树上所有结点的平衡因子只可能是−1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。\</p>
<h5 id="4-2-2平衡二叉树的平衡调整"><a href="#4-2-2平衡二叉树的平衡调整" class="headerlink" title="4.2.2平衡二叉树的平衡调整"></a>4.2.2平衡二叉树的平衡调整</h5><p>插入结点时，首先按照二叉排序树处理，若插入结点后破坏了平衡二叉树的特性，需对平衡二叉树进行调整。调整方法是：找到离插入结点最近且平衡因子绝对值超过1的祖先结点，以该结点为根的子树称为<strong>最小不平衡子树</strong>，可将重新平衡的范围局限于这棵子树。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5.png" alt="平衡二叉树的插入"></p>
<p>一般情况下，假设最小不平衡子树的根结点为A，则失去平衡后进行调整的规律可归纳为下列4种情况。</p>
<p>(1)LL型：由于在A左子树根结点的左子树上插入结点，A的平衡因子由1增至2，致使以A为根的子树失去平衡，则需进行一次向右的顺时针旋转操作，如图所示。</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LL.png" alt="LL"></p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LL%E7%A4%BA%E4%BE%8B.png" alt="LL示例"></p>
<p>(2)RR型：由于在A的右子树根结点的右子树上插入结点，A的平衡因子由−1变为−2，致使以A为根结点的子树失去平衡，则需进行一次向左的逆时针旋转操作，如图所示。</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RR.png" alt="RR"></p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RR%E7%A4%BA%E4%BE%8B.png" alt="RR示例"></p>
<p>(3)LR型：由于在A的左子树根结点的右子树上插入结点，A的平衡因子由1增至2，致使以A为根结点的子树失去平衡，则需进行两次旋转操作。第一次对B及其右子树进行逆时针旋转，C转上去成为B的根，这时变成了LL型，所以第二次进行LL型的顺时针旋转即可恢复平衡。如果C原来有左子树，则调整C的左子树为B的右子树，如图所示。</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LR.png" alt="LR"></p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LR%E7%A4%BA%E4%BE%8B.png" alt="LR示例"></p>
<p>(4)RL型：由于在A的右子树根结点的左子树上插入结点，A的平衡因子由−1变为−2，致使以A为根结点的子树失去平衡，则旋转方法和LR型相对称，也需进行两次旋转，先顺时针右旋，再逆时针左旋，如图所示。</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RL.png" alt="RL"></p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RL%E7%A4%BA%E4%BE%8B.png" alt="RL示例"></p>
<h4 id="4-3B-树"><a href="#4-3B-树" class="headerlink" title="4.3B-树"></a>4.3B-树</h4><h5 id="4-3-1B-树的定义"><a href="#4-3-1B-树的定义" class="headerlink" title="4.3.1B-树的定义"></a>4.3.1B-树的定义</h5><p>一棵m阶的B-树，或为空树，或为满足下列特性的m叉树：<br>（1）树中每个结点至多有m棵子树；<br>（2）若根结点不是叶子结点，则至少有两棵子树；<br>（3）除根之外的所有非终端结点至少有$\lceil{m&#x2F;2}\rceil$棵子树；则至少含有$\lceil{m&#x2F;2}\rceil-1$个关键字<br>（4）所有的叶子结点都出现在同一层次上，并且不带信息，通常称为失败结点（失败结点并不存在，指向这些结点的指针为空。引入失败结点是为了便于分析B-树的查找性能）；<br>（5）所有的非终端结点最多有m−1个关键字，结点的结构如图所示。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B-%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84.png" alt="B-树的结点结构"></p>
<p>其中，Ki（i&#x3D;1, …, n）为关键字，且$K_i&lt;K_i+1$（i&#x3D;1, …, n−1）;<br>$P_i$（i&#x3D;0, …, n）为指向子树根结点的指针，且指针$P_i$−1所指子树中所有结点的关键字均小于$K_i$（i&#x3D;1, …, n）;<br>$P_n$所指子树中所有结点的关键字均大于Kn，[插图]为关键字的个数（或n+1为子树个数）。<br>从上述定义可以看出，<strong>对任一关键字Ki而言，Pi−1相当于指向其“左子树”，Pi相当于指向其“右子树”。</strong><br>B-树具有平衡、有序、多路的特点，图所示为一棵4阶的B-树，能很好地说明其特点。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4%E9%98%B6B-%E6%A0%91.png" alt="4阶B-树"></p>
<p>（1）所有叶子结点均在同一层次，这体现出其平衡的特点。<br>（2）树中每个结点中的关键字都是有序的，且关键字Ki“左子树”中的关键字均小于Ki，而其“右子树”中的关键字均大于Ki，这体现出其有序的特点。<br>（3）除叶子结点外，有的结点中有一个关键字，两棵子树，有的结点中有两个关键字，三棵子树，这种4阶的B-树最多有三个关键字，四棵子树，这体现出其多路的特点。<br>在具体实现时，为记录其双亲结点，B-树结点的存储结构通常增加一个parent指针，指向其双亲结点，存储结构示意图如图所示。</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B-%E6%A0%91%E7%BB%93%E7%82%B9%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="B-树结点的存储结构"></p>
<p>重要结论：<br>n个关键字的m阶B-树高度h的范围为：$\log_m^{n+1} ≤ h ≤ \log_{\lceil{m&#x2F;2}\rceil}^{\frac{n+1}{2}}+1$\</p>
<h5 id="4-3-2B-树的查找"><a href="#4-3-2B-树的查找" class="headerlink" title="4.3.2B-树的查找"></a>4.3.2B-树的查找</h5><p>将给定值key与根结点的各个关键字K1, K2, …, Kj（1≤j≤m−1）进行比较，由于该关键字序列是有序的，所以查找时可采用顺序查找，也可采用折半查找。查找时：<br>① 若key&#x3D;Ki（1≤i≤j），则查找成功；<br>② 若key&lt;K1，则顺着指针P0所指向的子树继续向下查找；<br>③ 若Ki&lt;key&lt;Ki+1（1≤i≤j−1），则顺着指针Pi所指向的子树继续向下查找；<br>④ 若key&gt;Kj，则顺着指针Pj所指向的子树继续向下查找。如果在自上而下的查找过程中，找到了值为key的关键字，则查找成功；如果直到叶子结点也未找到，则查找失败。<br>如果在自上而下的查找过程中，找到了值为key的关键字，则查找成功；如果直到叶子结点也未找到，则查找失败。\</p>
<h5 id="4-3-3B-树的插入"><a href="#4-3-3B-树的插入" class="headerlink" title="4.3.3B-树的插入"></a>4.3.3B-树的插入</h5><p>① 在B-树中查找给定关键字的记录，若查找成功，则插入操作失败；否则将新记录作为空指针ap插入到查找失败的叶子结点的上一层结点（由q指向）中。<br>② 若插入新记录和空指针后，q指向的结点的关键字个数未超过m−1，则插入操作成功，否则转入步骤③。<br>③ 以该结点的第$\lceil{m&#x2F;2}\rceil$个关键字$K_{\lceil{m&#x2F;2}\rceil}$为拆分点，将该结点分成3个部分：$K_{\lceil{m&#x2F;2}\rceil}$左边部分、$K_{\lceil{m&#x2F;2}\rceil}$右边部分。$K_{\lceil{m&#x2F;2}\rceil}$左边部分仍然保留在原结点中；$K_{\lceil{m&#x2F;2}\rceil}$右边部分存放在一个新创建的结点（由ap指向）中；关键字值为$K_{\lceil{m&#x2F;2}\rceil}$的记录和指针ap插入到q的双亲结点中。因q的双亲结点增加一个新的记录，所以必须对q的双亲结点重复②和③的操作，依次类推，直至由q指向的结点是根结点，转入步骤④。<br>④ 由于根结点无双亲，则由其分裂产生的两个结点的指针ap和q，以及关键字为$K_{\lceil{m&#x2F;2}\rceil}$的记录构成一个新的根结点。此时，B-的高度增加1。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B-%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5.png" alt="B-树的插入"></p>
<h4 id="4-4B-树"><a href="#4-4B-树" class="headerlink" title="4.4B+树"></a>4.4B+树</h4><p>B+树是一种B-树的变形树，更适合用于文件索引系统。</p>
<p>一棵m阶的B+树和m阶的B-树的差异在于：<br>（1）有n棵子树的结点中含有n个关键字；<br>（2）所有的叶子结点中包含了全部关键字的信息，以及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；<br>（3）所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。\</p>
<p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B+%E6%A0%91.png" alt="B+树"></p>
<h3 id="5-散列表的查找"><a href="#5-散列表的查找" class="headerlink" title="5.散列表的查找"></a>5.散列表的查找</h3><p><strong>散列查找法（Hash Search）<strong>的思想，它通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用</strong>关键字到地址的直接转换方法</strong>，而不需要反复比较。因此，散列查找法又叫<strong>杂凑法</strong>或<strong>散列法</strong>。</p>
<p>（1）<strong>散列函数和散列地址</strong>：在记录的存储位置p和其关键字key之间建立一个确定的对应关系H，使p&#x3D;H(key)，称这个对应关系H为散列函数，p为散列地址。<br>（2）<strong>散列表</strong>：一个有限连续的地址空间，用以存储按散列函数计算得到相应散列地址的数据记录。通常散列表的存储空间是一个一维数组，散列地址是数组的下标。<br>（3）<strong>冲突和同义词</strong>：对不同的关键字可能得到同一散列地址，即key1≠key2，而H(key1)&#x3D;H(key2)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，key1与key2互称为同义词。\</p>
<p>散列查找法主要研究以下两方面的问题：（1）如何构造散列函数；（2）如何处理冲突。</p>
<p>构造散列函数的几种常用方法:<br>1．数字分析法<br>如果事先知道关键字集合，且每个关键字的位数比散列表的地址码位数多，每个关键字由n位数组成，如$k_1 k_2 … k_n$，则可以从关键字中提取数字分布比较均匀的若干位作为散列地址。<br>2．平方取中法<br>通常在选定散列函数时不一定能知道关键字的全部情况，取其中哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，如果取关键字平方后的中间几位或其组合作为散列地址，则使随机分布的关键字得到的散列地址也是随机的，具体所取的位数由表长决定。平方取中法是一种较常用的构造散列函数的方法。<br>3．折叠法<br>将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为散列地址，这种方法称为折叠法。根据数位叠加的方式，可以把折叠法分为移位叠加和边界叠加两种。移位叠加是将分割后每一部分的最低位对齐，然后相加；边界叠加是将两个相邻的部分沿边界来回折叠，然后对齐相加。<br>4．除留余数法<br>假设散列表表长为m，选择一个不大于m的数p，用p去除关键字，除后所得余数为散列地址，即H(key)&#x3D;key%p这个方法的关键是选取适当的p，一般情况下，可以选p为小于表长的最大质数。例如，表长m&#x3D;100，可取p&#x3D;97。除留余数法计算简单，适用范围非常广，是最常用的构造散列函数的方法。它不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模，这样能够保证散列地址一定落在散列表的地址空间中。\</p>
<p>处理冲突的方法:<br>1．开放地址法<br>把记录都存储在散列表数组中，当某一记录关键字key的初始散列地址H0&#x3D;H(key)发生冲突时，以H0为基础，采取合适方法计算得到另一个地址H1，如果H1仍然发生冲突，以H1为基础再求下一个地址H2，若H2仍然冲突，再求得H3。依次类推，直至Hk不发生冲突为止，则Hk为该记录在表中的散列地址。<br>这种方法在寻找“下一个”空的散列地址时，原来的数组空间对所有的元素都是开放的，所以称为<strong>开放地址法</strong>。<br>通常把寻找“下一个”空位的过程称为探测，上述方法可用如下公式表示：Hi&#x3D;(H(key)+di)%mi&#x3D;1, 2, …, k (k≤m−1)其中，H(key)为散列函数，m为散列表表长，di为增量序列。<br>根据di取值的不同，可以分为以下3种探测方法。<br>（1）线性探测法<br>di&#x3D;1, 2, 3, …, m−1<br>这种探测方法可以将散列表假想成一个循环表，发生冲突时，从冲突地址的下一单元顺序寻找空单元，如果到最后一个位置也没找到空单元，则回到表头开始继续查找，直到找到一个空位，就把此元素放入此空位中。如果找不到空位，则说明散列表已满，需要进行溢出处理。<br>（2）二次探测法<br>di&#x3D;12, −12, 22,−22, 32,…,+k2, −k2 (k≤m&#x2F;2)<br>（3）伪随机探测法<br>di&#x3D;伪随机数序列<br>当表中i，i+1，i+2位置上已填有记录时，下一个散列地址为i、i+1、i+2和i+3的记录都将填入i+3的位置，这种在处理冲突过程中发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象称作“二次聚集”（或称作“堆积”），即在处理同义词的冲突过程中又添加了非同义词的冲突。\</p>
<p>线性探测法的优点是：只要散列表未填满，总能找到一个不发生冲突的地址。缺点是：会产生“二次聚集”现象。<br>而二次探测法和伪随机探测法的优点是：可以避免“二次聚集”现象。缺点也很显然：不能保证一定找到不发生冲突的地址。\</p>
<p>2．链地址法</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><img src="/bestfyw.github.io/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83.png" alt="排序比较"></p>
<h3 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h3><h4 id="1-1直接插入排序"><a href="#1-1直接插入排序" class="headerlink" title="1.1直接插入排序"></a>1.1直接插入排序</h4><h4 id="1-2折半插入排序"><a href="#1-2折半插入排序" class="headerlink" title="1.2折半插入排序"></a>1.2折半插入排序</h4><h4 id="1-3希尔排序"><a href="#1-3希尔排序" class="headerlink" title="1.3希尔排序"></a>1.3希尔排序</h4><h3 id="2-交换排序"><a href="#2-交换排序" class="headerlink" title="2.交换排序"></a>2.交换排序</h3><h4 id="2-1冒泡排序"><a href="#2-1冒泡排序" class="headerlink" title="2.1冒泡排序"></a>2.1冒泡排序</h4><h4 id="2-2快速排序"><a href="#2-2快速排序" class="headerlink" title="2.2快速排序"></a>2.2快速排序</h4><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h3><h4 id="3-1简单选择排序"><a href="#3-1简单选择排序" class="headerlink" title="3.1简单选择排序"></a>3.1简单选择排序</h4><h4 id="3-2树形选择排序"><a href="#3-2树形选择排序" class="headerlink" title="3.2树形选择排序"></a>3.2树形选择排序</h4><h4 id="3-3堆排序"><a href="#3-3堆排序" class="headerlink" title="3.3堆排序"></a>3.3堆排序</h4><h3 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a>4.归并排序</h3><h3 id="5-基数排序"><a href="#5-基数排序" class="headerlink" title="5.基数排序"></a>5.基数排序</h3><h4 id="5-1多关键字的排序"><a href="#5-1多关键字的排序" class="headerlink" title="5.1多关键字的排序"></a>5.1多关键字的排序</h4><h4 id="5-2链式基数排序"><a href="#5-2链式基数排序" class="headerlink" title="5.2链式基数排序"></a>5.2链式基数排序</h4><h3 id="6-外部排序"><a href="#6-外部排序" class="headerlink" title="6.外部排序"></a>6.外部排序</h3><p>外部排序基本上由两个相对独立的阶段组成。首先，按可用内存大小，将外存上含n个记录的文件分成若干长度为l的子文件或段（segment），依次读入内存并利用有效的内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写入外存，通常称这些有序子文件为归并段或顺串（run）；然后，对这些归并段进行逐趟归并，使归并段（有序的子文件）逐渐由小至大，直至得到整个有序文件为止。</p>
<h4 id="6-1多路平衡归并的实现"><a href="#6-1多路平衡归并的实现" class="headerlink" title="6.1多路平衡归并的实现"></a>6.1多路平衡归并的实现</h4><h4 id="6-2置换-选择排序"><a href="#6-2置换-选择排序" class="headerlink" title="6.2置换-选择排序"></a>6.2置换-选择排序</h4><h4 id="6-3最佳归并树"><a href="#6-3最佳归并树" class="headerlink" title="6.3最佳归并树"></a>6.3最佳归并树</h4>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/bestfyw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/bestfyw.github.io/2023/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/" rel="prev" title="数据结构-数组">
                  <i class="fa fa-angle-left"></i> 数据结构-数组
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/bestfyw.github.io/2023/06/26/vim%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E6%8B%AC%E5%8F%B7%E5%BC%95%E5%8F%B7/" rel="next" title="vim自动补全括号引号等">
                  vim自动补全括号引号等 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">fywfeng</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/bestfyw.github.io/js/comments.js"></script><script src="/bestfyw.github.io/js/utils.js"></script><script src="/bestfyw.github.io/js/motion.js"></script><script src="/bestfyw.github.io/js/sidebar.js"></script><script src="/bestfyw.github.io/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/bestfyw.github.io/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/bestfyw.github.io/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"f1ywin/bestfyw.github.io","issue_term":"url","theme":"github-light"}</script>
<script src="/bestfyw.github.io/js/third-party/comments/utterances.js"></script>

</body>
</html>
